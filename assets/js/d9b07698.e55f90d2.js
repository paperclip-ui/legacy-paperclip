"use strict";(self.webpackChunk_paperclip_ui_website=self.webpackChunk_paperclip_ui_website||[]).push([[9772],{3905:function(e,n,t){t.d(n,{Zo:function(){return c},kt:function(){return u}});var a=t(67294);function l(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function s(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?s(Object(t),!0).forEach((function(n){l(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,l=function(e,n){if(null==e)return{};var t,a,l={},s=Object.keys(e);for(a=0;a<s.length;a++)t=s[a],n.indexOf(t)>=0||(l[t]=e[t]);return l}(e,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)t=s[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(l[t]=e[t])}return l}var r=a.createContext({}),p=function(e){var n=a.useContext(r),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},c=function(e){var n=p(e.components);return a.createElement(r.Provider,{value:n},e.children)},m={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,l=e.mdxType,s=e.originalType,r=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),d=p(t),u=l,h=d["".concat(r,".").concat(u)]||d[u]||m[u]||s;return t?a.createElement(h,i(i({ref:n},c),{},{components:t})):a.createElement(h,i({ref:n},c))}));function u(e,n){var t=arguments,l=n&&n.mdxType;if("string"==typeof e||l){var s=t.length,i=new Array(s);i[0]=d;var o={};for(var r in n)hasOwnProperty.call(n,r)&&(o[r]=n[r]);o.originalType=e,o.mdxType="string"==typeof e?e:l,i[1]=o;for(var p=2;p<s;p++)i[p]=t[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},38218:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return o},contentTitle:function(){return r},metadata:function(){return p},toc:function(){return c},default:function(){return d}});var a=t(87462),l=t(63366),s=(t(67294),t(3905)),i=["components"],o={id:"usage-syntax",title:"Paperclip Syntax",sidebar_label:"Syntax"},r=void 0,p={unversionedId:"usage-syntax",id:"usage-syntax",title:"Paperclip Syntax",description:"Basics",source:"@site/docs/usage-syntax.md",sourceDirName:".",slug:"/usage-syntax",permalink:"/docs/usage-syntax",editUrl:"https://github.com/paperclipui/paperclip/edit/master/packages/paperclip-website/docs/usage-syntax.md",tags:[],version:"current",frontMatter:{id:"usage-syntax",title:"Paperclip Syntax",sidebar_label:"Syntax"},sidebar:"docs",previous:{title:"Installation",permalink:"/docs/installation"},next:{title:"Configuring",permalink:"/docs/configure-paperclip"}},c=[{value:"Basics",id:"basics",children:[],level:3},{value:"Styling",id:"styling",children:[{value:"Nested rules",id:"nested-rules",children:[],level:3},{value:"Element scoping",id:"element-scoping",children:[],level:3},{value:":within(ancestor-selector)",id:"withinancestor-selector",children:[],level:3},{value:"@mixin",id:"mixin",children:[],level:3},{value:"Re-using media queries",id:"re-using-media-queries",children:[],level:3},{value:"@export",id:"export",children:[],level:3},{value:"$class-reference",id:"class-reference",children:[],level:3},{value:":global",id:"global",children:[],level:3}],level:2},{value:"Import",id:"import",children:[{value:"inject-styles",id:"inject-styles",children:[],level:4}],level:2},{value:"Components",id:"components",children:[{value:"Exporting components",id:"exporting-components",children:[],level:3},{value:"Overriding component styles",id:"overriding-component-styles",children:[{value:"Using scoped styles",id:"using-scoped-styles",children:[],level:4}],level:3},{value:"Changing the tag name",id:"changing-the-tag-name",children:[],level:3}],level:2},{value:"Bindings",id:"bindings",children:[{value:"Child bindings",id:"child-bindings",children:[],level:3},{value:"Attribute bindings",id:"attribute-bindings",children:[],level:3},{value:"Optional bindings",id:"optional-bindings",children:[],level:3},{value:"Variant styles",id:"variant-styles",children:[],level:3}],level:2},{value:"Fragments",id:"fragments",children:[],level:2},{value:"Annotations",id:"annotations",children:[{value:"@frame",id:"frame",children:[],level:3}],level:2}],m={toc:c};function d(e){var n=e.components,t=(0,l.Z)(e,i);return(0,s.kt)("wrapper",(0,a.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("h3",{id:"basics"},"Basics"),(0,s.kt)("p",null,"You can use regular HTML & CSS in Paperclip. For example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-html",metastring:"live height=260px",live:!0,height:"260px"},"<style>\n  div {\n    color: purple;\n    font-size: 32px;\n    font-family: papyrus;\n  }\n</style>\n<div>I'm purple!!</div>\n")),(0,s.kt)("p",null,"The big difference between Paperclip and regular HTML & CSS is that CSS in Paperclip is scoped. This means that styles won't leak into other documents. "),(0,s.kt)("p",null,"You ",(0,s.kt)("em",{parentName:"p"},"can")," define global CSS, but you need to be explicit about that using the ",(0,s.kt)("a",{parentName:"p",href:"#global"},(0,s.kt)("inlineCode",{parentName:"a"},":global()"))," selector. You can also override styles into other documents using ",(0,s.kt)("a",{parentName:"p",href:"#class-reference"},"selector reference syntax"),". You can also use styles defined within another document by using the ",(0,s.kt)("a",{parentName:"p",href:"#@export"},"@export")," or ",(0,s.kt)("a",{parentName:"p",href:"#inject-styles"},"inject-styles"),"."),(0,s.kt)("h2",{id:"styling"},"Styling"),(0,s.kt)("h3",{id:"nested-rules"},"Nested rules"),(0,s.kt)("p",null,"Nested rules eliminates some redundancy around defining style selectors."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Syntax"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-css"},".parent-rule {\n\n  /* equivalent to: .parent-rule .child-rule */\n  .child-rule {\n\n  }\n  /* equivalent to: .parent-rule--variant */\n  &--variant-rule {\n\n  }\n}\n")),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Example"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-html",metastring:"height=500px",height:"500px"},'// file: nested-style-demo.pc\n<style>\n  .container {\n    .header {\n      font-size: 32px;\n      font-weight: 600;\n      color: red;\n    }\n    .content {\n      font-size: 18px;\n      color: blue;\n    }\n  }\n</style>\n\n<div class="container">\n  <div class="header">\n    Header\n  </div>\n  <div class="content">\n    content\n  </div>\n</div>\n')),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"&")," token can be used to combine the ",(0,s.kt)("em",{parentName:"p"},"parent")," selector in nested rules like so:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-html",metastring:"height=550px",height:"550px"},'// file: nested-combine-demo.pc\n<style>\n  .button {\n    font-family: Noteworthy;\n    background: grey;\n    display: inline-block;\n    border: 2px solid grey;\n    border-radius: 2px;\n    padding: 2px 10px;\n    &--secondary {\n      color: grey;\n      background: transparent;\n    }\n    &.preview {\n      margin: 10px;\n    }\n  }\n</style>\n\n<div class="button preview">\n  Button primary\n</div>\n<div class="button button--secondary preview">\n  Button secondary\n</div>\n')),(0,s.kt)("p",null,"Also note that you can nest ",(0,s.kt)("inlineCode",{parentName:"p"},"@media")," queries like so:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-css"},"div {\n  @media screen and (max-width: 400px) {\n    color: blue;\n  }\n}\n")),(0,s.kt)("h3",{id:"element-scoping"},"Element scoping"),(0,s.kt)("p",null,"Style blocks that are the defined within elements are ",(0,s.kt)("em",{parentName:"p"},"scoped")," to that element. For example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-html",metastring:"height=320px",height:"320px"},"<div>\n  <div>\n    <style>\n      color: red;\n      span {\n        color: blue;\n      }\n    </style>\n    I'm red text!  \n    <span>I'm blue text!</span>\n  </div>\n  I'm black text\n</div>\n")),(0,s.kt)("p",null,"Declarations defined directly in the style elements like the example above are applied to the parent element."),(0,s.kt)("p",null,"Scoped styles are recommended since they keep your styles & elements together in one spot, which makes them a bit more maintainable. It also provides you an easier way to know exactly what's being styled at a glance."),(0,s.kt)("h3",{id:"withinancestor-selector"},":within(ancestor-selector)"),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},":within([ancestor-selector])")," allows you to apply styles within a parent or ancestor."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-html",metastring:"height=330px",height:"330px"},'<div class="bolder">\n  <div>\n    <style>\n\n      /* this style block is applied if a \n      parent / ancestor has .bolder class */\n      &:within(.bolder) {\n        font-weight: 600;\n      }\n    </style>\n    Some text\n  </div>\n</div>\n')),(0,s.kt)("h3",{id:"mixin"},"@mixin"),(0,s.kt)("p",null,"Style mixins are useful for defining a bundle of style declarations (like ",(0,s.kt)("inlineCode",{parentName:"p"},"color"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"font-size"),") that you then can include into style rules."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Syntax"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-css"},"@mixin mixin-name {\n  /* style props */\n  decl-name: decl-value;\n\n  /* nested rules */\n  div {\n    color: blue;\n  }\n\n  /* takes body of include statement */\n  @content;\n}\n")),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Including mixins syntax"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-css"},".my-style {\n  @include mixin-name;\n\n  @include mixin-with-content {\n    display: block;\n    div {\n      color: blue;\n    }\n  }\n}\n")),(0,s.kt)("p",null," ",(0,s.kt)("strong",{parentName:"p"},"Example"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-html",metastring:"height=670px",height:"670px"},'<style>\n  :global(:root) {\n    --font-family-default: Quotes Script;\n    --color-grey-100: #333;\n    --color-green-100: #0C0;\n  }\n  \n  @mixin color-text-green {\n    color: var(--color-green-100);\n  }\n  \n  @mixin default-text {\n    font-family: var(--font-family-default);\n    color: var(--color-grey-100);\n    font-size: 32px;\n  }\n  \n  .message {\n\n    /* @include includes style mixins; you can have any number of them separated by spaces. */\n    @include default-text;\n    @include color-text-green;\n    text-decoration: underline;\n  }\n</style>\n\n<div class="message">\n  What has to be broken before you can use it?\n</div>\n')),(0,s.kt)("h3",{id:"re-using-media-queries"},"Re-using media queries"),(0,s.kt)("p",null,"Media queries are re-usable in Paperclip by using the following pattern:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-css"},"@mixin desktop {\n  @media screen and (max-width: 1400px) {\n    @content;\n  }\n}\n\ndiv {\n  @include desktop {\n    font-size: 24px;\n  }\n}\n")),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Example"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-html",metastring:"live height=500px",live:!0,height:"500px"},'// file: main.pc\n<import src="./breakpoints.pc" as="breakpoints" />\n\n\x3c!--\n  @frame { visible: false }\n--\x3e\n<div component as="App">\n  <style>\n    font-family: sans-serif;\n    @include breakpoints.desktop {\n      font-size: 18px;\n    }\n    @include breakpoints.mobile {\n      font-size: 72px;\n    }\n  </style>\n  {children}\n</div>\n\n\x3c!--\n  @frame { title: "App / Desktop", width: 1050, height: 421, x: 89, y: -295 }\n--\x3e\n<App>\n  I\'m some content\n</App>\n\n\x3c!--\n  @frame { title: "App / Mobile", width: 326, height: 507, x: 102, y: 261 }\n--\x3e\n<App>\n  I\'m some content\n</App>\n\n// file: breakpoints.pc\n<style>\n  @export {\n    @mixin desktop {\n      @media screen and (max-width: 1400px) {\n        @content;\n      }\n    }\n    @mixin mobile {\n      @media screen and (max-width: 400px) {\n        @content;\n      }\n    }\n  }\n</style>\n')),(0,s.kt)("h3",{id:"export"},"@export"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"@export")," rule allows you to export styles to other documents, as well as application code."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Syntax"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-css"},"@export {\n  .my-style {\n    /* styles here */\n  }\n\n  @keyframes my-keyframe {\n    /* keyframe code here */\n  }\n\n  @mixin my-mixin {\n    /* styles here */\n  }\n}\n")),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Example"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-html",metastring:"height=300px",height:"300px"},'// file: main.pc\n<import src="./styles.pc" as="styles" />\n\n\n\x3c!-- $ is a class reference - docs below --\x3e\n<div class="$styles.default-text">\n  <style>\n    @include styles.big-text;\n    animation: styles.pulse 1s infinite;\n  </style>\n\n  Hello again!\n</div>\n\n// file: styles.pc\n\n<style>\n\n  /* Exported mixins */\n\n  /* @export docs below */\n  @export {\n    @mixin text-color-green-default {\n      color: green;\n    }\n    @mixin big-text {\n      font-size: 32px;\n    }\n  }\n\n  /* Exported classes */\n\n  @export {\n    .default-text {\n      font-family: Herculanum;\n      letter-spacing: 0.05em;\n    }\n  }\n\n  /* Exported animations */\n\n  @export {\n    @keyframes pulse {\n      0% {\n        opacity: 1;\n      }\n      50% {\n        opacity: 0.5;\n      }\n      100% {\n        opacity: 1;\n      }\n    }\n  }\n</style>\n')),(0,s.kt)("p",null,"Note that you ",(0,s.kt)("em",{parentName:"p"},"must")," wrap styles around ",(0,s.kt)("inlineCode",{parentName:"p"},"@export")," if you want to reference them. "),(0,s.kt)("blockquote",null,(0,s.kt)("p",{parentName:"blockquote"},"On that note, I'd recommend only exporting things that you need in other documents since export keywords (",(0,s.kt)("inlineCode",{parentName:"p"},"@export"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"export"),") make it clear around what's public & private. ")),(0,s.kt)("p",null,"You can reference class names in React code like so:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},'import * as cx from "classnames";\nimport * as typography from "./typography.pc";\n<div className={cx(\n  typography.classNames["default-text"]\n)}>\n')),(0,s.kt)("p",null,"Note that ",(0,s.kt)("inlineCode",{parentName:"p"},".header-text")," is not exported, so it's not available in our app code."),(0,s.kt)("h3",{id:"class-reference"},"$class-reference"),(0,s.kt)("p",null,"Paperclip allows you to explicitly reference class selectors, which is helpful if you're looking to reference or overrides styles in other documents. "),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Syntax"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-html"},'<div class="$class-name" />\n\n<div class="$imported-doc.class-name" />\n')),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Example"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-html",metastring:"height=180px",height:"180px"},'// file: main.pc\n<import src="./atoms.pc" as="atoms" />\n\n<span class="$atoms.font-default">\n  Hello\n</span>\n// file: atoms.pc\n\n<style>\n  @export {\n    .font-default {\n      font-family: Helvetica;\n      color: blue;\n      font-size: 32px;\n      letter-spacing: 0.05em;\n    }\n  }\n</style>\n')),(0,s.kt)("p",null,"You can also use class references to ",(0,s.kt)("a",{parentName:"p",href:"#overriding-component-styles"},"override component styles"),"."),(0,s.kt)("h3",{id:"global"},":global"),(0,s.kt)("p",null,"All style rules are scoped by default to the document they're defined in. This ensures that they don't leak & have unintended side-effects. However, there ",(0,s.kt)("em",{parentName:"p"},"are")," rare cases when you may need to define a global style rule, such as styling HTML defined outside of Paperclip that doesn't have a way to define a ",(0,s.kt)("inlineCode",{parentName:"p"},"class")," attribute. "),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Syntax"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-css"},":global(.my-selector-here > div ~ .another-selector) {\n  name: value;\n}\n")),(0,s.kt)("p",null,"Here's an example that stylizes parts of ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/JedWatson/react-select"},"react-select"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-html"},'<style>\n\n  .wrapper {\n    \n    /* global for now so that we get tests to pass */\n    :global(.select__) {\n      &control {\n        display: flex;\n        background: var(--color-background);\n\n        /* more declarations here */\n\n        &--is-focused {\n          /* more declarations here */\n        }\n\n        &:hover {\n          /* more declarations here */\n        }\n      }\n      &value-container,\n      &single-value,\n      &multi-value__label,\n      &input {\n        /* more declarations here */\n      }\n\n      /* selectors here */\n    }\n  }\n</style>\n\n<div export component as="Wrapper" class="wrapper">\n  {children}\n</div>\n')),(0,s.kt)("p",null,"Here's how you use the above styles in React code:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},"import * as ui from './Select.pc';\n\n// Keep the select styles locked in\n<ui.Wrapper>\n  <DynamicSelect classNamePrefix=\"select\" {...props} />\n</ui.Wrapper>\n\n")),(0,s.kt)("p",null,"Try to avoid ",(0,s.kt)("inlineCode",{parentName:"p"},":global")," selectors whenever possible since they leak into other documents, and may result in unintended side-effects. If you need to use ",(0,s.kt)("inlineCode",{parentName:"p"},":global"),", try to wrap it around a style rule that's scoped to the document. For example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-css"},"/* Safer to use */\n.container {\n  :global(body) {\n\n  }\n}\n")),(0,s.kt)("h2",{id:"import"},"Import"),(0,s.kt)("p",null,"You can import ",(0,s.kt)("a",{parentName:"p",href:"#styling"},"styles")," & ",(0,s.kt)("a",{parentName:"p",href:"#components"},"components")," from other files. "),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Syntax"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-html"},'<import src="./path/to/document.pc" as="unique-namespace" />\n')),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Example"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-html",metastring:"height=330px",height:"330px"},'// file: main.pc\n<import src="./pane.pc" as="pane" />\n<import src="./atoms.pc" as="atoms" />\n\n<pane.Container>\n  <pane.Header>\n    <span class="$atoms.font-big">\n      Header content\n    </span>\n  </pane.Header>\n  <pane.Content>\n    Some content\n  </pane.Content>\n</pane.Container>\n\n\n// file: pane.pc\n<import src="./atoms.pc" as="atoms" />\n<style>\n  @mixin padded {\n    margin: 0px 8px;\n  }\n</style>\n\n<div export component as="Container" class="Container">\n  <style>\n    @include atoms.font-default;\n  </style>\n  {children}\n</div>\n\n<div export component as="Header" class="Header">\n  <style>\n    @include padded;\n    font-size: 18px;\n    font-weight: 600;\n  </style>\n  {children}\n</div>\n\n<div export component as="Content" class="Content">\n  <style>\n    @include padded;\n  </style>\n  {children}\n</div>\n\n\x3c!-- Preview --\x3e\n\nNothing here!\n\n// file: atoms.pc\n\n<style>\n  @export {\n    @mixin font-default {\n      font-family: Helvetica;\n    }\n    .font-big {\n      @include font-default;\n      font-size: 24px;\n    }\n  }\n</style>\n')),(0,s.kt)("p",null,"The import ",(0,s.kt)("inlineCode",{parentName:"p"},"as")," keyword defines a namespace that you can use to access exported properties defined within other documents, like above."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Other examples"),":"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#export"},"Exporting styles")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#exporting-components"},"Exporting components"))),(0,s.kt)("h4",{id:"inject-styles"},"inject-styles"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"inject-styles")," props injects all of the import's exported styles into the current document. For example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-html"},'<import src="./tailwind.css" inject-styles />\n\n<div class="font-sans">\n  Styles from tailwind.css\n</div>\n')),(0,s.kt)("p",null,"This is particularly useful for third-party CSS since ",(0,s.kt)("inlineCode",{parentName:"p"},"inject-styles")," includes ",(0,s.kt)("em",{parentName:"p"},"all")," CSS selectors (class, ID, element, etc) into the current scope. Note that injected styles are only applied to the current document, so if you're importing components from another file, those components won't be styled. For example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-html"},'<import src="./tailwind.css" inject-styles />\n<import src="./some-module.pc" as="module" />\n\n<div class="font-sans">\n  Styles from tailwind.css\n\n  \x3c!-- injected styles are NOT applied to this element --\x3e\n  <module.Test />\n</div>\n')),(0,s.kt)("p",null,"Note that ",(0,s.kt)("inlineCode",{parentName:"p"},".css")," files are a special case since all selectors are automatically exported. If you want to inject styles from a ",(0,s.kt)("inlineCode",{parentName:"p"},".pc")," file, you'll need to explicitly export the styles that you'd like to inject. For example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-html"},"<style> \n  @export {\n    * {\n      box-sizing: border-box;\n    }\n\n    .font-large {\n      font-size: 24px;\n    }\n  }\n\n  .this-class-is-not-applied {\n    color: orange;\n  }\n</style>\n")),(0,s.kt)("p",null,"\ud83d\udc46 everything that is defined within ",(0,s.kt)("inlineCode",{parentName:"p"},"export")," can be injected into a document. Here's how you use the above example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-html"},'<import src="./my-module.pc" inject-styles />\n<div class="font-large">\n  I\'m large text\n</div>\n')),(0,s.kt)("h2",{id:"components"},"Components"),(0,s.kt)("p",null,"Components are your UI building blocks. Just add a ",(0,s.kt)("inlineCode",{parentName:"p"},"component")," attribute to a root element (doesn't have a parent)."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Syntax"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-html"},'\n\x3c!-- defining the component --\x3e\n<element-name component as="my-component-name">\n</element-name>\n\n\x3c!-- using it --\x3e\n<my-component-name />\n')),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Example"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-html",metastring:"height=400px",height:"400px"},'\n\x3c!-- class and class can be used interchangeably --\x3e\n\x3c!--\n  @frame { visible: false }\n--\x3e\n<div component as="Message" class="Message">\n  <style>\n    font-family: Comic Sans MS;\n    font-size: 32px;\n    color: #F0F;\n  </style>\n  {children}\n</div>\n\n\x3c!-- Preview section --\x3e\n\n<Message>\n  Hooray!\n</Message>\n')),(0,s.kt)("h3",{id:"exporting-components"},"Exporting components"),(0,s.kt)("p",null,"Components can be exported to be used in application code, as well as other documents."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Syntax"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-html"},'\n\x3c!-- just add the "export" attribute to any component --\x3e\n<div export component as="MyComponent">\n</div>\n')),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Example"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-html",metastring:"height=1000px",height:"1000px"},'// file: todos.pc\n<import src="./styles.pc" as="styles" />\n\n\x3c!-- Components --\x3e\n\n\x3c!--\n  @frame { visible: false }\n--\x3e\n<div export component as="App" class="$styles.App">\n  {children}\n</div>\n\n\x3c!--\n  @frame { visible: false }\n--\x3e\n<input export component as="NewItemInput" {onChange} />\n\n\x3c!--\n  @frame { visible: false }\n--\x3e\n<div export component as="Header" class="$styles.Header">\n  <h4>Todos</h4>\n  {children}\n</div>\n\n\x3c!--\n  @frame { visible: false }\n--\x3e\n<ul export component as="List" class="$styles.List">\n  {children}\n</ul>\n\n\x3c!--\n  @frame { visible: false }\n--\x3e\n<li export component as="Item" class="$styles.Item" {onClick}>\n  <input type="checkbox" checked={completed} /> \n  <span class="$styles.label">{children}</span>\n</li>\n\n\x3c!-- Preview --\x3e\n\n<App>\n  <Header>\n    <NewItemInput />\n  </Header>\n  <List>\n    <Item>Wash car</Item>\n    <Item>Wash car</Item>\n    <Item completed>Wash car</Item>\n  </List>\n</App>\n\n// file: styles.pc\n\n\x3c!-- Typically in the same file as components, but they\'re here for this demo since they\'re not the focus. --\x3e\n<style>\n  @export {\n    .App {\n      font-family: Chalkduster;\n    }\n    .Header {  \n      h4 {\n        margin: 0;\n        margin-bottom: 8px;\n      }\n      margin-bottom: 8px;\n    }\n    .List {\n      margin: 0;\n      padding: 0;\n      list-style-type: none;\n    }\n    .Item {\n\n      // Needs\n      :global(input[type="checkbox"]) {\n        margin-right: 8px;\n        &:checked ~ .label {\n          text-decoration: line-through;\n        }\n      }\n    }\n  }\n</style>\n')),(0,s.kt)("p",null,"Here's how we can use this in our React app:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},'import React, { useRef, useState } from "react";\nimport * as ui from "./todos.pc"\n\nconst TodoApp = () => {\n  const [todos, setTodos] = useState([\n    { completed: true, label: "walk dog" },\n    { completed: true, label: "take out trash" }\n  ]);\n\n  const onNewInputChange = (event) => {\n    // code to add new todo item here\n  }\n\n  return <ui.App>\n    <ui.Header>\n      <NewItemInput onChange={} />\n      <ui.List>\n        {todos.map(({completed, label}, i) => (\n          <ui.Item \n            onClick={/* toggle completed handler here */} \n            completed={completed}>\n            {label}\n          <ui.Item>\n        ))}\n      </ui.List>\n    </ui.Header>\n  </ui.App>;\n}\n')),(0,s.kt)("p",null,"We can also use our exported component in other Paperclip documents. Here's an example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-html",metastring:"height=370px",height:"370px"},'// file: importing-components-demo.pc\n<import src="./todos.pc" as="todos" />\n\n<style>\n  .preview {\n    display: flex;\n    &-item {\n      margin-left: 20px;\n    }\n  }\n</style>\n\n<div class="preview">\n  <todos.Preview class="$preview-item" />\n  <todos.EmptyPreview class="$preview-item" />\n</div>\n\n// file: todos.pc\n<import src="./styles.pc" as="styles" />\n\n\x3c!-- Components --\x3e\n\n\x3c!--\n  @frame { visible: false }\n--\x3e\n<div export component as="App" class="$styles.App {class?}">\n  {children}\n</div>\n\n\x3c!--\n  @frame { visible: false }\n--\x3e\n<input export component as="NewItemInput" {onChange} />\n\n\x3c!--\n  @frame { visible: false }\n--\x3e\n<div export component as="Header" class="$styles.Header">\n  <h4>Todos</h4>\n  {children}\n</div>\n\n\x3c!--\n  @frame { visible: false }\n--\x3e\n<ul export component as="List" class="$styles.List">\n  {children}\n</ul>\n\n\x3c!--\n  @frame { visible: false }\n--\x3e\n<li export component as="Item" class="$styles.Item" {onClick}>\n  <input type="checkbox" checked={completed} /> \n  <span class="$styles.label">{children}</span>\n</li>\n\n\x3c!-- Export re-usable previews that can be used\nin other previews --\x3e\n\n\x3c!--\n  @frame { visible: false }\n--\x3e\n<App export component as="Preview" {class?}>\n  <Header>\n    <NewItemInput />\n  </Header>\n  <List>\n    <Item>Clean cat car</Item>\n    <Item>Wash car</Item>\n    <Item completed>Wash car</Item>\n  </List>\n</App>\n\n\n\x3c!--\n  @frame { visible: false }\n--\x3e\n<App export component as="EmptyPreview" {class?}>\n  <Header>\n    <NewItemInput />\n  </Header>\n  Nothing to see here\n</App>\n\n\x3c!-- render main preview --\x3e\n<Preview />\n\n// file: styles.pc\n\n\x3c!-- Typically in the same file as components, but they\'re here for this demo since they\'re not the focus. --\x3e\n<style>\n  @export {\n    .App {\n      font-family: Chalkduster;\n    }\n    .Header {  \n      h4 {\n        margin: 0;\n        margin-bottom: 8px;\n      }\n      margin-bottom: 8px;\n    }\n    .List {\n      margin: 0;\n      padding: 0;\n      list-style-type: none;\n    }\n    .Item {\n\n      // Needs\n      :global(input[type="checkbox"]) {\n        margin-right: 8px;\n        &:checked ~ .label {\n          text-decoration: line-through;\n        }\n      }\n    }\n  }\n</style>\n')),(0,s.kt)("h3",{id:"overriding-component-styles"},"Overriding component styles"),(0,s.kt)("p",null,"You can override styles in other components assuming that a component exposes an attribute that's bound to ",(0,s.kt)("inlineCode",{parentName:"p"},"class"),". "),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Syntax"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-html"},'attributeBoundToClassName="$class-name"\n')),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Example"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-html",metastring:"height=270px",height:"270px"},'// file: style-override-demo.pc\n<import as="Message" src="./message.pc" />\n<style>\n  .my-style-override {\n    text-decoration: underline;\n  }\n</style>\n<Message class="$my-style-override">\n  Hello World\n</Message>\n\n// file: message.pc\n\n\x3c!--\n  @frame { visible: false }\n--\x3e\n<div export component as="default" class="{class?}">\n  <style>\n      font-size: 24px;\n      font-family: Helvetica;\n  </style>\n  {children}\n</div>\n')),(0,s.kt)("p",null,"Check out ",(0,s.kt)("a",{parentName:"p",href:"#class-reference"},"class references")," for more information on how to use ",(0,s.kt)("inlineCode",{parentName:"p"},"$"),"."),(0,s.kt)("h4",{id:"using-scoped-styles"},"Using scoped styles"),(0,s.kt)("p",null,"Alternatively, you can overriding your components appearance by using scoped styles like so:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-html",metastring:"height=400px",height:"400px"},'\n\x3c!-- Note that class is still necessary here! --\x3e\n\x3c!--\n  @frame { visible: false }\n--\x3e\n<div export component as="Message" {class?}>\n  <style>\n    font-family: sans-serif;\n    color: red;\n  </style>\n  {children}\n</div>\n\n<Message>\n  <style>\n    color: blue;\n  </style>\n\n  I\'m blue text!\n</Message>\n')),(0,s.kt)("p",null,"Note that you need to provide a ",(0,s.kt)("inlineCode",{parentName:"p"},"class")," in your component for inline style overrides to work."),(0,s.kt)("p",null,"\u261d\ud83c\udffb this approach keeps your overrides together, which can be a bit easier to read. The other benefit to this approach is that your code remains portable since everything's in one spot. "),(0,s.kt)("h3",{id:"changing-the-tag-name"},"Changing the tag name"),(0,s.kt)("p",null,"You may want to change the native tag name of a component. An example of this is a ",(0,s.kt)("inlineCode",{parentName:"p"},"Button")," component that may be a ",(0,s.kt)("inlineCode",{parentName:"p"},"button")," or ",(0,s.kt)("inlineCode",{parentName:"p"},"a")," tag. "),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Syntax")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-html"},'<button export component as="Button" {tagName?}>\n  {children}\n</button>\n')),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Example")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-html",metastring:"height=270px",height:"270px"},'// file: demo.pc \n\n\x3c!--\n  @frame { visible: false }\n--\x3e\n<input component as="Input" {tagName?} {placeholder} />\n\n<div>\n  <Input placeholder="I\'m a text input" />\n  <Input tagName="textarea" placeholder="I\'m a text area" />\n</div>\n\n')),(0,s.kt)("h2",{id:"bindings"},"Bindings"),(0,s.kt)("p",null,"Bindings allow you to define dynamic behavior in components."),(0,s.kt)("h3",{id:"child-bindings"},"Child bindings"),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Syntax"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-html"},'<div component as="MyComponent">\n\n  \x3c!-- reserved keyword - takes element children. --\x3e\n  {children}\n  \n  \x3c!-- can be defined via attributes --\x3e\n  {anotherSlot}\n</div>\n')),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Example"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-html",metastring:"height=280px",height:"280px"},'\n\x3c!--\n  @frame { visible: false }\n--\x3e\n<h1 component as="Header">\n  {children}\n</h1>\n\n<Header>\n  I\'m a header\n</Header>\n')),(0,s.kt)("p",null,"There will probably be the case where you want to define multiple areas of a component for children to go into. Here's an example of that:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-html",metastring:"height=500px",height:"500px"},'// file: main.pc\n<import src="./styles.pc" as="styles" />\n\n\x3c!--\n  @frame { visible: false }\n--\x3e\n<div component as="Pane" class="$styles.Pane">\n  <div class="$styles.header">\n    <div class="$styles.title">{title}</div>\n    <div>{controls}</div>\n  </div>\n  <div class="$styles.content">\n    {children}\n  </div>\n</div>\n\n<div component as="AddButton">\n  +\n</div>\n\n<Pane title={<strong>My header</strong>} controls={<AddButton />}>\n  Lorem ipsum dolor sit amet, consectetur adipiscing elit.\n</Pane>\n\n// file: styles.pc\n\n\x3c!-- keeping this in another file so that it\'s not the center of attention --\x3e\n<style>\n  @export {\n    .Pane {\n      font-family: Courier;\n      width: 200px;\n      color: #333;\n      .header, .content {\n        padding: 4px 8px;\n      }\n      .header {\n        background: #C0C0C0;\n        display: flex;\n        .title {\n          flex-grow: 1;\n        }\n      }\n      .content {\n        background: #CFCFCFCF;\n        padding: 4px;\n      }\n    }\n  }\n</style>\n')),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"{title}")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"{controls}")," (and technically also ",(0,s.kt)("inlineCode",{parentName:"p"},"{children}"),") are considered ",(0,s.kt)("em",{parentName:"p"},"slots")," for child nodes to go into, and they can be filled in via attributes:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-html"},"<Pane \n  title={<span>some title</span>} \n  controls={<button>A button</button>}>\n  Content children\n</Pane>\n")),(0,s.kt)("h3",{id:"attribute-bindings"},"Attribute bindings"),(0,s.kt)("p",null,"You can define dynamic attributes on your elements. For example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-html",metastring:"height=450px",height:"450px"},'// file: buttons.pc\n<import src="./typography.pc" as="typography" />\n<import src="./styles.pc" as="styles" />\n\n\x3c!-- Components --\x3e\n\n\x3c!-- Generally I\'d recommend just a `{class}` binding instead of `{customClassName}` class name, which I\'m only using here to make more clear around how it works. --\x3e\n\x3c!--\n  @frame { visible: false }\n--\x3e\n<div component as="Button" \n  class="$styles.button {customClassName}">\n  {children}\n</div>\n\n\n<Button customClassName="$typography.big-text $typography.strong">\n  Button\n</Button>\n\n// file: styles.pc\n<import src="./typography.pc" as="typography" />\n<style>\n  @export {\n    .button {\n      color: red;\n      @include typography.default-text;\n    }\n  }\n</style>\n\n// file: typography.pc\n<style>\n  @export {\n    @mixin default-font {\n      font-family: Helvetica;\n    }\n    @mixin default-text {\n      @include default-font;\n      font-size: 18px;\n      color: #333;\n    }\n    .big-text {\n      @include default-font;\n      font-size: 32px;\n      font-weight: \n    }\n    .strong {\n      font-weight: 800;\n    }\n  }\n</style>\n')),(0,s.kt)("p",null,"Bindings can also be defined outside of string attributes. For example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-html"},'<div component as="Test">\n  <span class="title" ref={spanRef}>\n    {title}\n  </span>\n  {children}\n</div>\n')),(0,s.kt)("blockquote",null,(0,s.kt)("p",{parentName:"blockquote"},"Ref here is specific to React around referencing DOM nodes. ")),(0,s.kt)("p",null,"You can also use the shorthand approach like so:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-html"},'<div component as="Test" {ref}>\n  <span class="title">\n    {title}\n  </span>\n  {children}\n</div>\n')),(0,s.kt)("p",null,"This is particularly useful for making your code more DRY. For example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-html"},'<input\xa0export component as="Input" \n  {onChange?} \n  {defaultValue}\n  {value}\n/>\n')),(0,s.kt)("h3",{id:"optional-bindings"},"Optional bindings"),(0,s.kt)("p",null,"By default, bindings are required. So if you define ",(0,s.kt)("inlineCode",{parentName:"p"},"{class}")," on an element, that property will be required when compiled into application code. To make a binding optional, just add a ",(0,s.kt)("inlineCode",{parentName:"p"},"?")," after the binding name like so:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-html"},'<div component as="Message" {class?}>\n  {children}\n</div>\n')),(0,s.kt)("p",null,"\u261d\ud83c\udffb Here, ",(0,s.kt)("inlineCode",{parentName:"p"},"class")," is optional, whereas ",(0,s.kt)("inlineCode",{parentName:"p"},"children")," is not. When compiled to TypeScript, here's what you get:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript"},"/* other generated code here */\n\ntype MessageProps = {\n  class?: Function,\n  children: ReactNode,\n};\n\nexport const Message: React.FC<MessageProps>;\n")),(0,s.kt)("h3",{id:"variant-styles"},"Variant styles"),(0,s.kt)("p",null,"The variant style syntax allows you to conditionally apply styles. For example:"),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Syntax"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-html"},'<div component as="MyComponent" class:variant-name="class-name">\n</div>\n\n\x3c!-- defining variant-name will apply class-name style --\x3e\n<MyComponent variant-name />\n')),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Example"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-html",metastring:"height=900px",height:"900px"},'\n\x3c!--\n  @frame { visible: false }\n--\x3e\n<div component as="Header"\n  class:big="big"\n  class:medium="medium"\n  class:small="small">\n\n  <style>\n    font-family: Luminari;\n    font-size: 12px;\n\n    /* I recommend that you do this instead of &.big to avoid\n    CSS specificity issues */\n    &.big {\n      font-size: 32px;\n    }\n    &.medium {\n      font-size: 18px;\n    }\n    &.small {\n      font-size: 12px;\n    }\n\n  </style>\n\n  {children}\n</div>\n\n<div>\n  <Header big>\n    Big header\n  </Header>\n  <Header medium>\n    Medium header\n  </Header>\n  <Header small>\n    Small header\n  </Header>\n  <Header>\n    Regular header\n  </Header>\n</div>\n')),(0,s.kt)("h2",{id:"fragments"},"Fragments"),(0,s.kt)("p",null,"Fragments are useful if you want to render a collection of elements. For example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-html",metastring:"height=350px",height:"350px"},'\x3c!--\n  @frame { visible: false }\n--\x3e\n<ul component as="List">\n  {listItems}\n</ul>\n\n<List\n  listItems={<fragment>\n    <li>feed fish</li>\n    <li>feed cat</li>\n    <li>feed me</li>\n  </fragment>}\n/>\n')),(0,s.kt)("p",null,"You can also define components from them:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-html"},'<fragment component as="Items">\n  <li>Item</li>\n  <li>Item 2</li>\n  <li>Item 3</li>\n  <li>Item 4</li>\n</fragment>\n\n<ul>\n  <Items />\n</ul>\n')),(0,s.kt)("h2",{id:"annotations"},"Annotations"),(0,s.kt)("p",null,"Annotations allow you to specify additional metadata about your elements -- this is used particularly\nfor documentation & other visual helpers when developing your UIs."),(0,s.kt)("h3",{id:"frame"},"@frame"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"@frame")," annotation allows to you to specify preview frame dimensions for your element. For example:"),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"x/y/width/height")," dimensions can be specified visually in the preview window. "),(0,s.kt)("p",null,"To hide frames from rendering, you can specify ",(0,s.kt)("inlineCode",{parentName:"p"},"visible: false")," like so:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-html"},"\x3c!-- \n  @frame { visible: false }\n--\x3e\nThis frame isn't visible in the preview\n")))}d.isMDXComponent=!0}}]);